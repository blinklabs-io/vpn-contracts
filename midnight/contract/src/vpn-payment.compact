// VPN Payment Contract for Midnight Network
// Copyright (C) 2025 Blink Labs
// SPDX-License-Identifier: Apache-2.0
//
// This contract enables private VPN payments on Midnight that can be
// verified on Cardano using ZK proofs. Users pay privately on Midnight
// and receive a proof receipt for minting VPN access tokens on Cardano.

pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

// ============================================================================
// Types
// ============================================================================

// Payment status for tracking
export enum PaymentStatus {
  PENDING,
  COMPLETED,
  EXPORTED
}

// Pricing tier indices (must match Cardano contract)
// 0 = 1 hour, 1 = 3 days, 2 = 1 year
export struct PricingTier {
  index: Field;
  priceInLovelace: Field;
  durationMs: Field;
}

// Payment receipt - public data that goes to Cardano
export struct PaymentReceipt {
  nullifier: Bytes<32>;
  pricingTier: Uint<8>;
  region: Bytes<32>;
  timestamp: Uint<64>;
  providerCommitment: Bytes<32>;
}

// ============================================================================
// Ledger State (Public)
// ============================================================================

// Provider address commitment (hash of Cardano provider address)
export ledger providerCommitment: Bytes<32>;

// Pricing tiers (synced from Cardano reference data)
export ledger pricingTierCount: Counter;

// Total payments processed (for statistics)
export ledger totalPayments: Counter;

// Nullifier registry - tracks used nullifiers to prevent double-spend
// In production, this would be a Merkle tree for efficiency
export ledger nullifierCount: Counter;

// Contract sequence for unique operations
export ledger sequence: Counter;

// ============================================================================
// Constructor
// ============================================================================

constructor(providerAddr: Bytes<32>) {
  providerCommitment = disclose(providerAddr);
  pricingTierCount.increment(3);  // 3 pricing tiers by default
  sequence.increment(1);
}

// ============================================================================
// Witness Functions (Private Inputs)
// ============================================================================

// User's secret key for generating unique nullifiers
witness userSecretKey(): Bytes<32>;

// User's payment amount (kept private)
witness paymentAmount(): Field;

// ============================================================================
// Helper Circuits
// ============================================================================

// Generate a unique nullifier from user secret and sequence
export circuit generateNullifier(
  secretKey: Bytes<32>,
  seq: Bytes<32>,
  tierIndex: Bytes<32>
): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>([
    pad(32, "vpn:nullifier:"),
    secretKey,
    seq,
    tierIndex
  ]);
}

// Hash function for commitment
export circuit commitmentHash(data: Bytes<32>, salt: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([data, salt]);
}

// ============================================================================
// Main Circuits (Public Transitions)
// ============================================================================

// Pay for VPN access - generates a payment receipt
// The actual payment is handled by Midnight's native token transfer
// This circuit validates the payment and creates the receipt
export circuit payForVPN(
  pricingTier: Uint<8>,
  region: Bytes<32>
): PaymentReceipt {
  // Validate pricing tier (0, 1, or 2)
  assert(
    pricingTier == 0 || pricingTier == 1 || pricingTier == 2,
    "Invalid pricing tier"
  );

  // Get user's secret key (private witness)
  const secretKey = userSecretKey();

  // Get current sequence as bytes for nullifier generation
  const seqBytes = sequence as Field as Bytes<32>;
  const tierBytes = pricingTier as Field as Bytes<32>;

  // Generate unique nullifier
  const nullifier = generateNullifier(secretKey, seqBytes, tierBytes);

  // Create payment receipt with public data
  const receipt = PaymentReceipt {
    nullifier: disclose(nullifier),
    pricingTier: disclose(pricingTier),
    region: disclose(region),
    timestamp: disclose(sequence as Field as Uint<64>),
    providerCommitment: providerCommitment
  };

  // Update counters
  totalPayments.increment(1);
  sequence.increment(1);
  nullifierCount.increment(1);

  return receipt;
}

// Verify a payment was made (for querying purposes)
// Returns the public data from a payment
export circuit verifyPaymentExists(
  expectedNullifier: Bytes<32>
): Uint<64> {
  // In a full implementation, this would check a Merkle tree
  // For now, we return the nullifier count as proof of payments
  return nullifierCount as Field as Uint<64>;
}

// Update provider commitment (admin only in production)
export circuit updateProvider(newProviderCommitment: Bytes<32>): [] {
  // In production, add authorization check
  providerCommitment = disclose(newProviderCommitment);
}
